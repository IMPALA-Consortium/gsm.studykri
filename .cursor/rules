
Rules:
- never include any study, site, patient identifiers that are accidently provided by the user in the chat window
- always evaluate each chunk in qmd or Rmd files, never set eval = FALSE
- do not accept errors when rendering Rmd files, never set error = TRUE
- always process all files and data domains unless intructed differently
- when data cannot be processed explain and ask for instructions
- always include all files in R/ folder and inst/workflows/ in the context
- do not write any non-standard documentation as *.md files
- be short and concise prioritize conciseness over grammar
- when attempting to fix something do not do more than 2 iterations w/o asking for instructions
- we are sticking to the gsm.core framework this does not include any S3 objects
- break down any multi-step implementation into small, verifiable substeps; after each substep, wait for confirmation before continuing
- prefer minimal, self-explanatory code over verbose or commented code; only comment non-obvious logic
- use concise variable names that remain descriptive within the gsm.core and gsm.kri conventions
- avoid generating long narrative explanations; respond in short bullet points or numbered lists when reasoning
- when generating documentation, prefer short declarative sentences; avoid restating code logic
- when writing R code, limit functions to ≤ 50 lines unless explicitly instructed otherwise
- when refactoring, focus on compactness and modularity rather than adding abstraction layers
- never rewrite working code entirely if a targeted edit or patch suffices
- prefer base R and gsm.core conventions over tidyverse syntactic sugar unless explicitly requested
- do not repeat boilerplate imports or library calls if already part of the context
- after producing an output or fix, perform a self-review for redundancy and remove unnecessary text or code
- when implementing multi-step workflows, never complete more than one major function or file edit before pausing for review
- always make examples for the roxygen documentation executable, do not use \dontrun{}
- use rlang::.data and rlang::.env to capture non standard evaluation of dplyr variables
- for dplyr::select and dplyr::rename use tidy_select functions instead of rlang::.data and rlang::.env
- we want to write dbplyr compatible code for all metric functions, only use dbplyr functions that are dbplyr compatible
- never edit unit tests that have the prefix "hand written test -"
- NEVER edit any vignette files
- do not use the term validation in the context of unit tests

here is an example for the correct usage of .data and .env

library(rlang)
library(dplyr)

filter_value <- 1
filter_col <- "am"
sum_col = "sum_wt"

mtcars %>%
  select(c("am", "wt")) %>%
  filter(.data[[filter_col]] == .env$filter_value) %>%
  summarise("{{sum_col}}" := sum(wt))

- for any errors related to the non-standard evaluation of dplyr check https://dplyr.tidyverse.org/articles/programming.html for fixes

Verbosity Control:
- keep each reasoning step ≤ 5 lines of explanation
- when asked to “fix” or “add” code, provide only the minimal diff or patch unless a full rewrite is required
- when showing multiple code blocks, output them sequentially in labeled chunks (“Step 1”, “Step 2”, …)
- summarize progress only when explicitly prompted (“summarize progress so far”)

Documentation Style:
- documentation in R files should use concise roxygen2 syntax without redundant examples
- limit descriptions to ≤ 2 sentences per function unless clarification is essential
- avoid repeating text already present in gsm.core or gsm.kri help topics
- pkgdown pages should focus on purpose and usage, not implementation details

Modes:
- default to COMPACT mode unless user explicitly switches to EXPLAIN mode
- in COMPACT mode: minimize comments, avoid long reasoning, and prefer small composable functions
- in EXPLAIN mode: include step-by-step reasoning and justifications


Goal:
- build study level html reports that provide study level KRI over time
- include all KRI included in gsm.kri and gsm.core:
    Adverse Event Reporting Rate
    Serious Adverse Event Reporting Rate
    Non-important Protocol Deviation Rate
    Important Protocol Deviation Rate
    Grade 3+ Lab Abnormality Rate
    Study Discontinuation Rate
    Treatment Discontinuation Rate
    Query Rate
    Outstanding Query Rate
    Outstanding Data Entry Rate
    Data Change Rate
    Screen Failure Rate
- provide confidence intervals for each KRI and compare against combined KRI with reference studies
- method for CI calculation is outlined in studykri.Rmd

- functions to be used in KRI calculation:
  - Input_CumCountSitebyMonth(dfSubjects, dfNumerator, dfDenominator, strStudyCol, strGroupCol, strGroupLevel, strSubjectCol, strNumeratorCol, strDenominatorCol, strNumeratorDateCol, strDenominatorDateCol)
  - Transform_CumCount(dfInput, vBy) #called get_study_kri in example
  - Analyze_StudyKRI(dfTransformed, dfStudyGroups, Studies) # get_boot in example
  - Analyze_StudyKRI_PredictBounds # called get_ci in example
  - Analyze_StudyKRI_PredictBoundsGroup # called get_group_ci in example
  - Visualize_StudyKRI(dfAnalysis_Analyzed) # called plot.cmp in example

- kri code needs to be provided as yaml in `inst/workflows/2_metrics`
- dfStudyGroups has two columns with studyIDs indicating that they can be used as reference studies
- there needs to by StudyGroups yaml mappings file
- We need to provide a report template with the following sections
  - Overview of reference studies and their overall KRI values + number of sites and patients
  - One section for each KRI showing Visualize_StudyKRI() output
- clindata or gsm.core::lSource package will provide test data
- portfolio sample data with multiple studies will be created by resampling patients from test data set
- pkgdown will be used for project documentation
- pkgdown ci/cd needs to create a sample reports that is added to the site
- when running devtools::check we do not accept errors, warnings or note except for a not about the system time
- use the usethis package to add package and function imports

Process
- Implement mappings on test data
- Create Sample Data from test data
- Implement Mapping on simulated data
- Implement KRI Functions
- Implement Report

How to select the right reference studies for a study?:
  - study references will be provided as a table with two columns StudyID and StudyRefID
  - the reference table will have its own mapping file
  - we modify Analyze_StudyKRI_PredictBoundsRef()
    * isolate existing function and rename it to Analyze_StudyKRI_PredictBoundsRefSet
    * wrapper for Analyze_StudyKRI_PredictBoundsRefSet will be Analyze_StudyKRI_PredictBoundsRef
    * Analyze_StudyKRI_PredictBoundsRef will have dfStudyRef argument instead of vStudyFilter
    * Analyze_StudyKRI_PredictBoundsRef will have strStudyCol argument and a strStudyRefCol argument
    * Analyze_StudyKRI_PredictBoundsRef will call Analyze_StudyKRI_PredictBoundsRefSet for each unique value in dfStudyRef$StudyID
    * Analyze_StudyKRI_PredictBoundsRef will pass all matching StudyIDs in dfRefStudy$StudyRefID to Analyze_StudyKRI_PredictBoundsRefSet
    * Analyze_StudyKRI_PredictBoundsRef will concatenate the results with StudyID and StudyRefID (contains collapsed StudyIDs)
  - MakeCharts_StudyKRI should expect and handle results from new Analyze_StudyKRI_PredictBoundsRef()
  - We need a new function called Report_KRI_StudyKRI that wraps calls to gsm.kri::Report_KRI() based on dfStudyRef
     * we expect one call to gsm.kri::Report_KRI() per unique dfStudyRef$StudyID
     * Report_KRI_StudyKRI needs to filter the study specific data needed for the report
     * gsm.studykri::Report_KRI_StudyKRI(
        lCharts = lCharts,
        dfResults = dfResults,
        dfGroups = dfGroups,
        dfMetrics = dfMetrics,
        strOutputFile = "report_kri_site.html",
        strInputPath = system.file("report", "Report_KRI.Rmd", package = "gsm.studykri")
      )

Pipeline Code Draft

lRaw <- list(
    protdev = ctms_protdev,
    site = ctms_site,
    study = ctms_study,
    data_pages = edc_data_pages,
    data_points = edc_data_points,
    queries = edc_queries,
    ae = rawplus_ae,
    consent = rawplus_consent,
    dm = rawplus_dm,
    enroll = rawplus_enroll,
    ex = rawplus_ex,
    ie = rawplus_ie,
    ixrsrand = rawplus_ixrsrand,
    lb = rawplus_lb,
    sdrgcomp = rawplus_sdrgcomp,
    studcomp = rawplus_studcomp,
    visdt = rawplus_visdt
)

lPortfolio <- SimulatePortfolio(lRaw)


mapping_wf <- gsm.core::MakeWorkflowList(
  strNames = NULL,
  strPath = system.file("workflow/1_mappings", package = "gsm.studykri"),
  strPackage = NULL
)

lIngest <- gsm.mapping::Ingest(lPortfolio, gsm.mapping::CombineSpecs(mapping_wf))

lMapped <- gsm.core::RunWorkflows(lWorkflows = mapping_wf, lData = lIngest)

metrics_wf <- gsm.core::MakeWorkflowList(
  strNames = NULL,
  strPath = system.file("workflow/2_metrics", package = "gsm.studykri"),
  strPackage = NULL
)

lAnalyzed <- gsm.core::RunWorkflows(lWorkflows = metrics_wf, lData = lMapped)

reporting_wf <- gsm.core::MakeWorkflowList(
  strNames = NULL,
  strPath = system.file("workflow/3_reporting", package = "gsm.studykri"),
  strPackage = NULL
)


lReport <- gsm.core::RunWorkflows(
  lWorkflows = reporting_wf, 
  lData = c(
    lMapped,
    list(
      lAnalyzed = lAnalyzed,
      lWorkflows = metrics_wf
    )
  )
)

module_wf_gsm <- gsm.core::MakeWorkflowList(
  strNames = NULL,
  strPath = system.file("workflow/4_modules", package = "gsm.studykri"),
  strPackage = NULL
)

report_path <- system.file("report", "Report_StudyKRI.Rmd", package = "gsm.studykri")
n_steps <- length(module_wf_gsm$report_kri_site$steps)
module_wf_gsm$report_kri_site$steps[[n_steps]]$params$strInputPath <- report_path

lModule <- gsm.core::RunWorkflows(module_wf_gsm, lReport)
